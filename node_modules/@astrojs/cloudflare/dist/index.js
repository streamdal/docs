import { createRedirectsFromAstroRoutes } from "@astrojs/underscore-redirects";
import esbuild from "esbuild";
import * as fs from "node:fs";
import * as os from "node:os";
import { sep } from "node:path";
import { fileURLToPath, pathToFileURL } from "node:url";
import glob from "tiny-glob";
function getAdapter(isModeDirectory) {
  return isModeDirectory ? {
    name: "@astrojs/cloudflare",
    serverEntrypoint: "@astrojs/cloudflare/server.directory.js",
    exports: ["onRequest", "manifest"]
  } : {
    name: "@astrojs/cloudflare",
    serverEntrypoint: "@astrojs/cloudflare/server.advanced.js",
    exports: ["default"]
  };
}
const SHIM = `globalThis.process = {
	argv: [],
	env: {},
};`;
const SERVER_BUILD_FOLDER = "/$server_build/";
const potentialFunctionRouteTypes = ["endpoint", "page"];
function createIntegration(args) {
  let _config;
  let _buildConfig;
  const isModeDirectory = (args == null ? void 0 : args.mode) === "directory";
  let _entryPoints = /* @__PURE__ */ new Map();
  return {
    name: "@astrojs/cloudflare",
    hooks: {
      "astro:config:setup": ({ config, updateConfig }) => {
        updateConfig({
          build: {
            client: new URL(`.${config.base}`, config.outDir),
            server: new URL(`.${SERVER_BUILD_FOLDER}`, config.outDir),
            serverEntry: "_worker.mjs",
            redirects: false
          }
        });
      },
      "astro:config:done": ({ setAdapter, config }) => {
        setAdapter(getAdapter(isModeDirectory));
        _config = config;
        _buildConfig = config.build;
        if (config.output === "static") {
          throw new Error(`
  [@astrojs/cloudflare] \`output: "server"\` or \`output: "hybrid"\` is required to use this adapter. Otherwise, this adapter is not necessary to deploy a static site to Cloudflare.

`);
        }
        if (config.base === SERVER_BUILD_FOLDER) {
          throw new Error(`
  [@astrojs/cloudflare] \`base: "${SERVER_BUILD_FOLDER}"\` is not allowed. Please change your \`base\` config to something else.`);
        }
      },
      "astro:build:setup": ({ vite, target }) => {
        if (target === "server") {
          vite.resolve ||= {};
          vite.resolve.alias ||= {};
          const aliases = [{ find: "react-dom/server", replacement: "react-dom/server.browser" }];
          if (Array.isArray(vite.resolve.alias)) {
            vite.resolve.alias = [...vite.resolve.alias, ...aliases];
          } else {
            for (const alias of aliases) {
              vite.resolve.alias[alias.find] = alias.replacement;
            }
          }
          vite.ssr ||= {};
          vite.ssr.target = "webworker";
          vite.define = {
            "process.env": "process.env",
            ...vite.define
          };
        }
      },
      "astro:build:ssr": ({ entryPoints }) => {
        _entryPoints = entryPoints;
      },
      "astro:build:done": async ({ pages, routes, dir }) => {
        var _a, _b, _c, _d;
        const functionsUrl = new URL("functions/", _config.root);
        if (isModeDirectory) {
          await fs.promises.mkdir(functionsUrl, { recursive: true });
        }
        if (isModeDirectory && _buildConfig.split) {
          const entryPointsURL = [..._entryPoints.values()];
          const entryPaths = entryPointsURL.map((entry) => fileURLToPath(entry));
          const outputUrl = new URL("$astro", _buildConfig.server);
          const outputDir = fileURLToPath(outputUrl);
          await esbuild.build({
            target: "es2020",
            platform: "browser",
            conditions: ["workerd", "worker", "browser"],
            entryPoints: entryPaths,
            outdir: outputDir,
            allowOverwrite: true,
            format: "esm",
            bundle: true,
            minify: ((_b = (_a = _config.vite) == null ? void 0 : _a.build) == null ? void 0 : _b.minify) !== false,
            banner: {
              js: SHIM
            },
            logOverride: {
              "ignored-bare-import": "silent"
            }
          });
          const outputFiles = await glob(`**/*`, {
            cwd: outputDir,
            filesOnly: true
          });
          for (const outputFile of outputFiles) {
            const path = outputFile.split(sep);
            const finalSegments = path.map(
              (segment) => segment.replace(/(\_)(\w+)(\_)/g, (_, __, prop) => {
                return `[${prop}]`;
              }).replace(/(\_\-\-\-)(\w+)(\_)/g, (_, __, prop) => {
                return `[[${prop}]]`;
              })
            );
            finalSegments[finalSegments.length - 1] = finalSegments[finalSegments.length - 1].replace("entry.", "").replace(/(.*)\.(\w+)\.(\w+)$/g, (_, fileName, __, newExt) => {
              return `${fileName}.${newExt}`;
            });
            const finalDirPath = finalSegments.slice(0, -1).join(sep);
            const finalPath = finalSegments.join(sep);
            const newDirUrl = new URL(finalDirPath, functionsUrl);
            await fs.promises.mkdir(newDirUrl, { recursive: true });
            const oldFileUrl = new URL(`$astro/${outputFile}`, outputUrl);
            const newFileUrl = new URL(finalPath, functionsUrl);
            await fs.promises.rename(oldFileUrl, newFileUrl);
          }
        } else {
          const entryPath = fileURLToPath(new URL(_buildConfig.serverEntry, _buildConfig.server));
          const entryUrl = new URL(_buildConfig.serverEntry, _config.outDir);
          const buildPath = fileURLToPath(entryUrl);
          const finalBuildUrl = pathToFileURL(buildPath.replace(/\.mjs$/, ".js"));
          await esbuild.build({
            target: "es2020",
            platform: "browser",
            conditions: ["workerd", "worker", "browser"],
            entryPoints: [entryPath],
            outfile: buildPath,
            allowOverwrite: true,
            format: "esm",
            bundle: true,
            minify: ((_d = (_c = _config.vite) == null ? void 0 : _c.build) == null ? void 0 : _d.minify) !== false,
            banner: {
              js: SHIM
            },
            logOverride: {
              "ignored-bare-import": "silent"
            }
          });
          await fs.promises.rename(buildPath, finalBuildUrl);
          if (isModeDirectory) {
            const directoryUrl = new URL("[[path]].js", functionsUrl);
            await fs.promises.rename(finalBuildUrl, directoryUrl);
          }
        }
        const serverUrl = new URL(_buildConfig.server);
        await fs.promises.rm(serverUrl, { recursive: true, force: true });
        const cloudflareSpecialFiles = ["_headers", "_redirects", "_routes.json"];
        if (_config.base !== "/") {
          for (const file of cloudflareSpecialFiles) {
            try {
              await fs.promises.rename(
                new URL(file, _buildConfig.client),
                new URL(file, _config.outDir)
              );
            } catch (e) {
            }
          }
        }
        const routesExists = await fs.promises.stat(new URL("./_routes.json", _config.outDir)).then((stat) => stat.isFile()).catch(() => false);
        if (!routesExists) {
          const functionEndpoints = routes.filter((route) => potentialFunctionRouteTypes.includes(route.type) && !route.prerender).map((route) => {
            const includePattern = "/" + route.segments.flat().map((segment) => segment.dynamic ? "*" : segment.content).join("/");
            const regexp = new RegExp(
              "^\\/" + route.segments.flat().map((segment) => segment.dynamic ? "(.*)" : segment.content).join("\\/") + "$"
            );
            return {
              includePattern,
              regexp
            };
          });
          const staticPathList = (await glob(`${fileURLToPath(_buildConfig.client)}/**/*`, {
            cwd: fileURLToPath(_config.outDir),
            filesOnly: true
          })).filter((file) => cloudflareSpecialFiles.indexOf(file) < 0).map((file) => `/${file.replace(/\\/g, "/")}`);
          for (let page of pages) {
            let pagePath = prependForwardSlash(page.pathname);
            if (_config.base !== "/") {
              const base = _config.base.endsWith("/") ? _config.base.slice(0, -1) : _config.base;
              pagePath = `${base}${pagePath}`;
            }
            staticPathList.push(pagePath);
          }
          const redirectsExists = await fs.promises.stat(new URL("./_redirects", _config.outDir)).then((stat) => stat.isFile()).catch(() => false);
          if (redirectsExists) {
            const redirects = (await fs.promises.readFile(new URL("./_redirects", _config.outDir), "utf-8")).split(os.EOL).map((line) => {
              const parts = line.split(" ");
              if (parts.length < 2) {
                return null;
              } else {
                return parts[0].replace(/\/:.*?(?=\/|$)/g, "/*").replace(/\?.*$/, "");
              }
            }).filter(
              (line, index, arr) => line !== null && arr.indexOf(line) === index
            );
            if (redirects.length > 0) {
              staticPathList.push(...redirects);
            }
          }
          const redirectRoutes = routes.filter((r) => r.type === "redirect").map((r) => {
            return [r, ""];
          });
          const trueRedirects = createRedirectsFromAstroRoutes({
            config: _config,
            routeToDynamicTargetMap: new Map(Array.from(redirectRoutes)),
            dir
          });
          if (!trueRedirects.empty()) {
            await fs.promises.appendFile(
              new URL("./_redirects", _config.outDir),
              trueRedirects.print()
            );
          }
          staticPathList.push(...routes.filter((r) => r.type === "redirect").map((r) => r.route));
          let include = deduplicatePatterns(
            functionEndpoints.map((endpoint) => endpoint.includePattern)
          );
          let exclude = deduplicatePatterns(
            staticPathList.filter(
              (file) => functionEndpoints.some((endpoint) => endpoint.regexp.test(file))
            )
          );
          if (include.length === 0) {
            include = ["/"];
            exclude = ["/"];
          }
          if (include.length + exclude.length > staticPathList.length) {
            include = ["/*"];
            exclude = deduplicatePatterns(staticPathList);
          }
          await fs.promises.writeFile(
            new URL("./_routes.json", _config.outDir),
            JSON.stringify(
              {
                version: 1,
                include,
                exclude
              },
              null,
              2
            )
          );
        }
      }
    }
  };
}
function prependForwardSlash(path) {
  return path[0] === "/" ? path : "/" + path;
}
function deduplicatePatterns(patterns) {
  const openPatterns = [];
  return [...new Set(patterns)].sort((a, b) => a.length - b.length).filter((pattern) => {
    if (openPatterns.some((p) => p.test(pattern))) {
      return false;
    }
    if (pattern.endsWith("*")) {
      openPatterns.push(new RegExp(`^${pattern.replace(/(\*\/)*\*$/g, ".*")}`));
    }
    return true;
  });
}
export {
  createIntegration as default,
  getAdapter
};
