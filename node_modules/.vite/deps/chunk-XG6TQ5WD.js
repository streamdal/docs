// node_modules/nanostores/task/index.js
var tasks = 0;
var resolves = [];
function startTask() {
  tasks += 1;
  return () => {
    tasks -= 1;
    if (tasks === 0) {
      let prevResolves = resolves;
      resolves = [];
      for (let i of prevResolves)
        i();
    }
  };
}
function task(cb) {
  let endTask = startTask();
  return cb().finally(endTask);
}
function allTasks() {
  if (tasks === 0) {
    return Promise.resolve();
  } else {
    return new Promise((resolve) => {
      resolves.push(resolve);
    });
  }
}
function cleanTasks() {
  tasks = 0;
}

// node_modules/nanostores/clean-stores/index.js
var clean = Symbol("clean");
var cleanStores = (...stores) => {
  if (false) {
    throw new Error(
      "cleanStores() can be used only during development or tests"
    );
  }
  cleanTasks();
  for (let store of stores) {
    if (store) {
      if (store.mocked)
        delete store.mocked;
      if (store[clean])
        store[clean]();
    }
  }
};

// node_modules/nanostores/lifecycle/index.js
var START = 0;
var STOP = 1;
var SET = 2;
var NOTIFY = 3;
var BUILD = 4;
var MOUNT = 5;
var UNMOUNT = 6;
var REVERT_MUTATION = 10;
var on = (object, listener, eventKey, mutateStore) => {
  object.events = object.events || {};
  if (!object.events[eventKey + REVERT_MUTATION]) {
    object.events[eventKey + REVERT_MUTATION] = mutateStore((eventProps) => {
      object.events[eventKey].reduceRight((event, l) => (l(event), event), {
        shared: {},
        ...eventProps
      });
    });
  }
  object.events[eventKey] = object.events[eventKey] || [];
  object.events[eventKey].push(listener);
  return () => {
    let currentListeners = object.events[eventKey];
    let index = currentListeners.indexOf(listener);
    currentListeners.splice(index, 1);
    if (!currentListeners.length) {
      delete object.events[eventKey];
      object.events[eventKey + REVERT_MUTATION]();
      delete object.events[eventKey + REVERT_MUTATION];
    }
  };
};
var onStart = (store, listener) => on(store, listener, START, (runListeners) => {
  let originListen = store.listen;
  store.listen = (arg) => {
    if (!store.lc && !store.starting) {
      store.starting = true;
      runListeners();
      delete store.starting;
    }
    return originListen(arg);
  };
  return () => {
    store.listen = originListen;
  };
});
var onStop = (store, listener) => on(store, listener, STOP, (runListeners) => {
  let originOff = store.off;
  store.off = () => {
    runListeners();
    originOff();
  };
  return () => {
    store.off = originOff;
  };
});
var onSet = (store, listener) => on(store, listener, SET, (runListeners) => {
  let originSet = store.set;
  let originSetKey = store.setKey;
  if (store.setKey) {
    store.setKey = (changed, changedValue) => {
      let isAborted;
      let abort = () => {
        isAborted = true;
      };
      runListeners({
        abort,
        changed,
        newValue: { ...store.value, [changed]: changedValue }
      });
      if (!isAborted)
        return originSetKey(changed, changedValue);
    };
  }
  store.set = (newValue) => {
    let isAborted;
    let abort = () => {
      isAborted = true;
    };
    runListeners({ abort, newValue });
    if (!isAborted)
      return originSet(newValue);
  };
  return () => {
    store.set = originSet;
    store.setKey = originSetKey;
  };
});
var onNotify = (store, listener) => on(store, listener, NOTIFY, (runListeners) => {
  let originNotify = store.notify;
  store.notify = (changed) => {
    let isAborted;
    let abort = () => {
      isAborted = true;
    };
    runListeners({ abort, changed });
    if (!isAborted)
      return originNotify(changed);
  };
  return () => {
    store.notify = originNotify;
  };
});
var onBuild = (Template, listener) => on(Template, listener, BUILD, (runListeners) => {
  let originBuild = Template.build;
  Template.build = (...args) => {
    let store = originBuild(...args);
    runListeners({ store });
    return store;
  };
  return () => {
    Template.build = originBuild;
  };
});
var STORE_UNMOUNT_DELAY = 1e3;
var onMount = (store, initialize) => {
  let listener = (payload) => {
    let destroy = initialize(payload);
    if (destroy)
      store.events[UNMOUNT].push(destroy);
  };
  return on(store, listener, MOUNT, (runListeners) => {
    let originListen = store.listen;
    store.listen = (...args) => {
      if (!store.lc && !store.active) {
        store.active = true;
        runListeners();
      }
      return originListen(...args);
    };
    let originOff = store.off;
    store.events[UNMOUNT] = [];
    store.off = () => {
      originOff();
      setTimeout(() => {
        if (store.active && !store.lc) {
          store.active = false;
          for (let destroy of store.events[UNMOUNT])
            destroy();
          store.events[UNMOUNT] = [];
        }
      }, STORE_UNMOUNT_DELAY);
    };
    if (true) {
      let originClean = store[clean];
      store[clean] = () => {
        for (let destroy of store.events[UNMOUNT])
          destroy();
        store.events[UNMOUNT] = [];
        store.active = false;
        originClean();
      };
    }
    return () => {
      store.listen = originListen;
      store.off = originOff;
    };
  });
};

// node_modules/nanostores/action/index.js
var lastAction = Symbol();
var doAction = (store, actionName, cb, args) => {
  let tracker = { ...store };
  tracker.set = (...setArgs) => {
    store[lastAction] = actionName;
    store.set(...setArgs);
    delete store[lastAction];
  };
  if (store.setKey) {
    tracker.setKey = (...setArgs) => {
      store[lastAction] = actionName;
      store.setKey(...setArgs);
      delete store[lastAction];
    };
  }
  let result = cb(tracker, ...args);
  if (result instanceof Promise) {
    let endTask = startTask();
    return result.finally(endTask);
  }
  return result;
};
var action = (store, actionName, cb) => (...args) => doAction(store, actionName, cb, args);
var actionFor = (Template, actionName, cb) => {
  return (store, ...rest) => doAction(store, actionName, cb, rest);
};

// node_modules/nanostores/atom/index.js
var listenerQueue = [];
var notifyId = 0;
var atom = (initialValue, level) => {
  let currentListeners;
  let nextListeners = [];
  let store = {
    lc: 0,
    l: level || 0,
    value: initialValue,
    set(data) {
      store.value = data;
      store.notify();
    },
    get() {
      if (!store.lc) {
        store.listen(() => {
        })();
      }
      return store.value;
    },
    notify(changedKey) {
      currentListeners = nextListeners;
      let runListenerQueue = !listenerQueue.length;
      for (let i = 0; i < currentListeners.length; i += 2) {
        listenerQueue.push(
          currentListeners[i],
          store.value,
          changedKey,
          currentListeners[i + 1]
        );
      }
      if (runListenerQueue) {
        notifyId++;
        for (let i = 0; i < listenerQueue.length; i += 4) {
          let skip = false;
          for (let j = i + 7; j < listenerQueue.length; j += 4) {
            if (listenerQueue[j] < listenerQueue[i + 3]) {
              skip = true;
              break;
            }
          }
          if (skip) {
            listenerQueue.push(
              listenerQueue[i],
              listenerQueue[i + 1],
              listenerQueue[i + 2],
              listenerQueue[i + 3]
            );
          } else {
            listenerQueue[i](listenerQueue[i + 1], listenerQueue[i + 2]);
          }
        }
        listenerQueue.length = 0;
      }
    },
    listen(listener, listenerLevel) {
      if (nextListeners === currentListeners) {
        nextListeners = nextListeners.slice();
      }
      store.lc = nextListeners.push(listener, listenerLevel || store.l) / 2;
      return () => {
        if (nextListeners === currentListeners) {
          nextListeners = nextListeners.slice();
        }
        let index = nextListeners.indexOf(listener);
        if (~index) {
          nextListeners.splice(index, 2);
          store.lc--;
          if (!store.lc)
            store.off();
        }
      };
    },
    subscribe(cb, listenerLevel) {
      let unbind = store.listen(cb, listenerLevel);
      cb(store.value);
      return unbind;
    },
    off() {
    }
    /* It will be called on last listener unsubscribing.
       We will redefine it in onMount and onStop. */
  };
  if (true) {
    store[clean] = () => {
      nextListeners = [];
      store.lc = 0;
      store.off();
    };
  }
  return store;
};

// node_modules/nanostores/map/index.js
var map = (value = {}) => {
  let store = atom(value);
  store.setKey = function(key, newValue) {
    if (typeof newValue === "undefined") {
      if (key in store.value) {
        store.value = { ...store.value };
        delete store.value[key];
        store.notify(key);
      }
    } else if (store.value[key] !== newValue) {
      store.value = {
        ...store.value,
        [key]: newValue
      };
      store.notify(key);
    }
  };
  return store;
};

// node_modules/nanostores/map-template/index.js
function mapTemplate(init) {
  let Template = (id, ...args) => {
    if (!Template.cache[id]) {
      Template.cache[id] = Template.build(id, ...args);
    }
    return Template.cache[id];
  };
  Template.build = (id, ...args) => {
    let store = map({ id });
    onMount(store, () => {
      let destroy;
      if (init)
        destroy = init(store, id, ...args);
      return () => {
        delete Template.cache[id];
        if (destroy)
          destroy();
      };
    });
    return store;
  };
  Template.cache = {};
  if (true) {
    Template[clean] = () => {
      for (let id in Template.cache) {
        Template.cache[id][clean]();
      }
      Template.cache = {};
    };
  }
  return Template;
}

// node_modules/nanostores/listen-keys/index.js
function listenKeys(store, keys, listener) {
  let keysSet = /* @__PURE__ */ new Set([...keys, void 0]);
  return store.listen((value, changed) => {
    if (keysSet.has(changed)) {
      listener(value, changed);
    }
  });
}

// node_modules/nanostores/keep-mount/index.js
var keepMount = (store) => {
  store.listen(() => {
  });
};

// node_modules/nanostores/computed/index.js
var computed = (stores, cb) => {
  if (!Array.isArray(stores))
    stores = [stores];
  let diamondNotifyId;
  let diamondArgs = [];
  let run = () => {
    let args = stores.map((store) => store.get());
    if (diamondNotifyId !== notifyId || args.some((arg, i) => arg !== diamondArgs[i])) {
      diamondNotifyId = notifyId;
      diamondArgs = args;
      derived.set(cb(...args));
    }
  };
  let derived = atom(void 0, Math.max(...stores.map((s) => s.l)) + 1);
  onMount(derived, () => {
    let unbinds = stores.map((store) => store.listen(run, derived.l));
    run();
    return () => {
      for (let unbind of unbinds)
        unbind();
    };
  });
  return derived;
};

export {
  startTask,
  task,
  allTasks,
  cleanTasks,
  clean,
  cleanStores,
  onStart,
  onStop,
  onSet,
  onNotify,
  onBuild,
  STORE_UNMOUNT_DELAY,
  onMount,
  lastAction,
  action,
  actionFor,
  atom,
  map,
  mapTemplate,
  listenKeys,
  keepMount,
  computed
};
//# sourceMappingURL=chunk-XG6TQ5WD.js.map
