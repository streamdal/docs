{
  "version": 3,
  "sources": ["../../preact/test-utils/src/index.js"],
  "sourcesContent": ["import { options } from 'preact';\n\n/**\n * Setup a rerender function that will drain the queue of pending renders\n * @returns {() => void}\n */\nexport function setupRerender() {\n\toptions.__test__previousDebounce = options.debounceRendering;\n\toptions.debounceRendering = cb => (options.__test__drainQueue = cb);\n\treturn () => options.__test__drainQueue && options.__test__drainQueue();\n}\n\nconst isThenable = value => value != null && typeof value.then == 'function';\n\n/** Depth of nested calls to `act`. */\nlet actDepth = 0;\n\n/**\n * Run a test function, and flush all effects and rerenders after invoking it.\n *\n * Returns a Promise which resolves \"immediately\" if the callback is\n * synchronous or when the callback's result resolves if it is asynchronous.\n *\n * @param {() => void|Promise<void>} cb The function under test. This may be sync or async.\n * @return {Promise<void>}\n */\nexport function act(cb) {\n\tif (++actDepth > 1) {\n\t\t// If calls to `act` are nested, a flush happens only when the\n\t\t// outermost call returns. In the inner call, we just execute the\n\t\t// callback and return since the infrastructure for flushing has already\n\t\t// been set up.\n\t\t//\n\t\t// If an exception occurs, the outermost `act` will handle cleanup.\n\t\ttry {\n\t\t\tconst result = cb();\n\t\t\tif (isThenable(result)) {\n\t\t\t\treturn result.then(() => {\n\t\t\t\t\t--actDepth;\n\t\t\t\t}, (e) => {\n\t\t\t\t\t--actDepth;\n\t\t\t\t\tthrow e;\n\t\t\t\t})\n\t\t\t}\n\t\t} catch(e) {\n\t\t\t--actDepth;\n\t\t\tthrow e;\n\t\t}\n\t\t--actDepth;\n\t\treturn Promise.resolve();\n\t}\n\n\tconst previousRequestAnimationFrame = options.requestAnimationFrame;\n\tconst rerender = setupRerender();\n\n\t/** @type {() => void} */\n\tlet flush, toFlush;\n\n\t// Override requestAnimationFrame so we can flush pending hooks.\n\toptions.requestAnimationFrame = fc => (flush = fc);\n\n\tconst finish = () => {\n\t\ttry {\n\t\t\trerender();\n\t\t\twhile (flush) {\n\t\t\t\ttoFlush = flush;\n\t\t\t\tflush = null;\n\n\t\t\t\ttoFlush();\n\t\t\t\trerender();\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tif (!err) {\n\t\t\t\terr = e;\n\t\t\t}\n\t\t} finally {\n\t\t\tteardown();\n\t\t}\n\n\t\toptions.requestAnimationFrame = previousRequestAnimationFrame;\n\t\t--actDepth;\n\t};\n\n\tlet err;\n\tlet result;\n\n\ttry {\n\t\tresult = cb();\n\t} catch (e) {\n\t\terr = e;\n\t}\n\n\tif (isThenable(result)) {\n\t\treturn result.then(finish, err => {\n\t\t\tfinish();\n\t\t\tthrow err;\n\t\t});\n\t}\n\n\t// nb. If the callback is synchronous, effects must be flushed before\n\t// `act` returns, so that the caller does not have to await the result,\n\t// even though React recommends this.\n\tfinish();\n\tif (err) {\n\t\tthrow err;\n\t}\n\treturn Promise.resolve();\n}\n\n/**\n * Teardown test environment and reset preact's internal state\n */\nexport function teardown() {\n\tif (options.__test__drainQueue) {\n\t\t// Flush any pending updates leftover by test\n\t\toptions.__test__drainQueue();\n\t\tdelete options.__test__drainQueue;\n\t}\n\n\tif (typeof options.__test__previousDebounce != 'undefined') {\n\t\toptions.debounceRendering = options.__test__previousDebounce;\n\t\tdelete options.__test__previousDebounce;\n\t} else {\n\t\toptions.debounceRendering = undefined;\n\t}\n}\n"],
  "mappings": ";;;;;AAMO,SAASA,IAAAA;AAGf,SAFAC,EAAQC,IAA2BD,EAAQE,mBAC3CF,EAAQE,oBAAoB,SAAAC,IAAAA;AAAOH,WAAAA,EAAQI,IAAqBD;EAAlC,GACvB,WAAA;AAAA,WAAMH,EAAQI,KAAsBJ,EAAQI,EAAAA;EAA5C;AACP;AAED,IAAMC,IAAa,SAAAC,GAAAA;AAAAA,SAAkB,QAATA,KAAsC,cAAA,OAAdA,EAAMC;AAAlC;AAAxB,IAGIC,IAAW;AAWCC,SAAAA,EAAIN,IAAAA;AACnB,MAAA,EAAMK,IAAW,GAAG;AAOnB,QAAA;AACC,UAAME,IAASP,GAAAA;AACf,UAAIE,EAAWK,CAAAA;AACd,eAAOA,EAAOH,KAAK,WAAA;AAAA,YAChBC;QACF,GAAE,SAACG,GAAAA;AAEH,gBAAA,EADEH,GACIG;QACN,CAAA;IAKF,SAHOA,GAAAA;AAEP,YAAA,EADEH,GACIG;IACN;AAED,WAAA,EADEH,GACKI,QAAQC,QAAAA;EACf;AAED,MAIIC,GAAOC,GAJLC,IAAgChB,EAAQiB,uBACxCC,KAAWnB,EAAAA;AAMjBC,IAAQiB,wBAAwB,SAAAE,GAAAA;AAAAA,WAAOL,IAAQK;EAAb;AAElC,MAsBIC,GACAV,GAvBEW,IAAS,WAAA;AACd,QAAA;AAEC,WADAH,GAAAA,GACOJ;AACNC,YAAUD,GACVA,IAAQ,MAERC,EAAAA,GACAG,GAAAA;IAQD,SANQP,GAAAA;AACHS,YACJA,IAAMT;IAEP,UAbD;AAcCW,QAAAA;IACA;AAEDtB,MAAQiB,wBAAwBD,GAAAA,EAC9BR;EACF;AAKD,MAAA;AACCE,QAASP,GAAAA;EAGT,SAFQQ,GAAAA;AACRS,QAAMT;EACN;AAED,MAAIN,EAAWK,CAAAA;AACd,WAAOA,EAAOH,KAAKc,GAAQ,SAAAD,GAAAA;AAE1B,YADAC,EAAAA,GACMD;IACN,CAAA;AAOF,MADAC,EAAAA,GACID;AACH,UAAMA;AAEP,SAAOR,QAAQC,QAAAA;AACf;AAKM,SAASS,IAAAA;AACXtB,IAAQI,MAEXJ,EAAQI,EAAAA,GAAAA,OACDJ,EAAQI,IAAAA,WAGLJ,EAAQC,KAClBD,EAAQE,oBAAoBF,EAAQC,GAAAA,OAC7BD,EAAQC,KAEfD,EAAQE,oBAAAA;AAET;",
  "names": ["setupRerender", "options", "__test__previousDebounce", "debounceRendering", "cb", "__test__drainQueue", "isThenable", "value", "then", "actDepth", "act", "result", "e", "Promise", "resolve", "flush", "toFlush", "previousRequestAnimationFrame", "requestAnimationFrame", "rerender", "fc", "err", "finish", "teardown"]
}
