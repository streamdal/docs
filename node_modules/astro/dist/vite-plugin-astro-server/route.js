import mime from "mime";
import { attachToResponse } from "../core/cookies/index.js";
import { AstroErrorData, isAstroError } from "../core/errors/index.js";
import { warn } from "../core/logger/core.js";
import { loadMiddleware } from "../core/middleware/loadMiddleware.js";
import { isEndpointResult } from "../core/render/core.js";
import {
  createRenderContext,
  getParamsAndProps,
  tryRenderRoute
} from "../core/render/index.js";
import { createRequest } from "../core/request.js";
import { matchAllRoutes } from "../core/routing/index.js";
import { isPage, resolveIdToUrl, viteID } from "../core/util.js";
import { getSortedPreloadedMatches } from "../prerender/routing.js";
import { isServerLikeOutput } from "../prerender/utils.js";
import { PAGE_SCRIPT_ID } from "../vite-plugin-scripts/index.js";
import { log404 } from "./common.js";
import { getStylesForURL } from "./css.js";
import { preload } from "./index.js";
import { getComponentMetadata } from "./metadata.js";
import { handle404Response, writeSSRResult, writeWebResponse } from "./response.js";
import { getScriptsForURL } from "./scripts.js";
const clientLocalsSymbol = Symbol.for("astro.locals");
function getCustom404Route(manifest) {
  const route404 = /^\/404\/?$/;
  return manifest.routes.find((r) => route404.test(r.route));
}
async function matchRoute(pathname, env, manifest) {
  const { logging, settings, routeCache } = env;
  const matches = matchAllRoutes(pathname, manifest);
  const preloadedMatches = await getSortedPreloadedMatches({ env, matches, settings });
  for await (const { preloadedComponent, route: maybeRoute, filePath } of preloadedMatches) {
    try {
      await getParamsAndProps({
        mod: preloadedComponent,
        route: maybeRoute,
        routeCache,
        pathname,
        logging,
        ssr: isServerLikeOutput(settings.config)
      });
      return {
        route: maybeRoute,
        filePath,
        resolvedPathname: pathname,
        preloadedComponent,
        mod: preloadedComponent
      };
    } catch (e) {
      if (isAstroError(e) && e.title === AstroErrorData.NoMatchingStaticPathFound.title) {
        continue;
      }
      throw e;
    }
  }
  const altPathname = pathname.replace(/(index)?\.html$/, "");
  if (altPathname !== pathname) {
    return await matchRoute(altPathname, env, manifest);
  }
  if (matches.length) {
    const possibleRoutes = matches.flatMap((route) => route.component);
    warn(
      logging,
      "getStaticPaths",
      `${AstroErrorData.NoMatchingStaticPathFound.message(
        pathname
      )}

${AstroErrorData.NoMatchingStaticPathFound.hint(possibleRoutes)}`
    );
  }
  log404(logging, pathname);
  const custom404 = getCustom404Route(manifest);
  if (custom404) {
    const filePath = new URL(`./${custom404.component}`, settings.config.root);
    const preloadedComponent = await preload({ env, filePath });
    return {
      route: custom404,
      filePath,
      resolvedPathname: pathname,
      preloadedComponent,
      mod: preloadedComponent
    };
  }
  return void 0;
}
async function handleRoute({
  matchedRoute,
  url,
  pathname,
  status = getStatus(matchedRoute),
  body,
  origin,
  env,
  manifestData,
  incomingRequest,
  incomingResponse,
  manifest
}) {
  var _a;
  const { logging, settings } = env;
  if (!matchedRoute) {
    return handle404Response(origin, incomingRequest, incomingResponse);
  }
  const { config } = settings;
  const filePath = matchedRoute.filePath;
  const { route, preloadedComponent } = matchedRoute;
  const buildingToSSR = isServerLikeOutput(config);
  const request = createRequest({
    url,
    headers: buildingToSSR ? incomingRequest.headers : new Headers(),
    method: incomingRequest.method,
    body,
    logging,
    ssr: buildingToSSR,
    clientAddress: buildingToSSR ? incomingRequest.socket.remoteAddress : void 0,
    locals: Reflect.get(incomingRequest, clientLocalsSymbol)
    // Allows adapters to pass in locals in dev mode.
  });
  for (const [name, value] of Object.entries(config.server.headers ?? {})) {
    if (value)
      incomingResponse.setHeader(name, value);
  }
  const options = {
    env,
    filePath,
    preload: preloadedComponent,
    pathname,
    request,
    route
  };
  const middleware = await loadMiddleware(env.loader, env.settings.config.srcDir);
  if (middleware) {
    options.middleware = middleware;
  }
  const mod = options.preload;
  const { scripts, links, styles, metadata } = await getScriptsAndStyles({
    env: options.env,
    filePath: options.filePath
  });
  const renderContext = await createRenderContext({
    request: options.request,
    pathname: options.pathname,
    scripts,
    links,
    styles,
    componentMetadata: metadata,
    route: options.route,
    mod,
    env
  });
  const onRequest = (_a = options.middleware) == null ? void 0 : _a.onRequest;
  const result = await tryRenderRoute(route.type, renderContext, env, mod, onRequest);
  if (isEndpointResult(result, route.type)) {
    if (result.type === "response") {
      if (result.response.headers.get("X-Astro-Response") === "Not-Found") {
        const fourOhFourRoute = await matchRoute("/404", env, manifestData);
        return handleRoute({
          matchedRoute: fourOhFourRoute,
          url: new URL("/404", url),
          pathname: "/404",
          status: 404,
          body,
          origin,
          env,
          manifestData,
          incomingRequest,
          incomingResponse,
          manifest
        });
      }
      await writeWebResponse(incomingResponse, result.response);
    } else {
      let contentType = "text/plain";
      const filepath = route.pathname || route.segments.map((segment) => segment.map((p) => p.content).join("")).join("/");
      const computedMimeType = mime.getType(filepath);
      if (computedMimeType) {
        contentType = computedMimeType;
      }
      const response = new Response(
        result.encoding !== "binary" ? Buffer.from(result.body, result.encoding) : result.body,
        {
          status: 200,
          headers: {
            "Content-Type": `${contentType};charset=utf-8`
          }
        }
      );
      attachToResponse(response, result.cookies);
      await writeWebResponse(incomingResponse, response);
    }
  } else {
    if (result.status === 404 && has404Route(manifestData)) {
      const fourOhFourRoute = await matchRoute("/404", env, manifestData);
      return handleRoute({
        ...options,
        matchedRoute: fourOhFourRoute,
        url: new URL(pathname, url),
        status: 404,
        body,
        origin,
        env,
        manifestData,
        incomingRequest,
        incomingResponse,
        manifest
      });
    }
    let response = result;
    if (
      // We are in a recursion, and it's possible that this function is called itself with a status code
      // By default, the status code passed via parameters is computed by the matched route.
      //
      // By default, we should give priority to the status code passed, although it's possible that
      // the `Response` emitted by the user is a redirect. If so, then return the returned response.
      response.status < 400 && response.status >= 300
    ) {
      await writeSSRResult(request, response, incomingResponse);
      return;
    } else if (status && response.status !== status && (status === 404 || status === 500)) {
      response = new Response(result.body, { ...result, status });
    }
    await writeSSRResult(request, response, incomingResponse);
  }
}
async function getScriptsAndStyles({ env, filePath }) {
  const scripts = await getScriptsForURL(filePath, env.settings.config.root, env.loader);
  if (isPage(filePath, env.settings) && env.mode === "development") {
    scripts.add({
      props: { type: "module", src: "/@vite/client" },
      children: ""
    });
    scripts.add({
      props: {
        type: "module",
        src: await resolveIdToUrl(env.loader, "astro/runtime/client/hmr.js")
      },
      children: ""
    });
  }
  for (const script of env.settings.scripts) {
    if (script.stage === "head-inline") {
      scripts.add({
        props: {},
        children: script.content
      });
    } else if (script.stage === "page" && isPage(filePath, env.settings)) {
      scripts.add({
        props: { type: "module", src: `/@id/${PAGE_SCRIPT_ID}` },
        children: ""
      });
    }
  }
  const { urls: styleUrls, stylesMap } = await getStylesForURL(filePath, env.loader, env.mode);
  let links = /* @__PURE__ */ new Set();
  [...styleUrls].forEach((href) => {
    links.add({
      props: {
        rel: "stylesheet",
        href
      },
      children: ""
    });
  });
  let styles = /* @__PURE__ */ new Set();
  [...stylesMap].forEach(([url, content]) => {
    scripts.add({
      props: {
        type: "module",
        src: url
      },
      children: ""
    });
    styles.add({
      props: {
        type: "text/css",
        // Track the ID so we can match it to Vite's injected style later
        "data-astro-dev-id": viteID(new URL(`.${url}`, env.settings.config.root))
      },
      children: content
    });
  });
  const metadata = await getComponentMetadata(filePath, env.loader);
  return { scripts, styles, links, metadata };
}
function getStatus(matchedRoute) {
  if (!matchedRoute)
    return 404;
  if (matchedRoute.route.route === "/404")
    return 404;
  if (matchedRoute.route.route === "/500")
    return 500;
}
function has404Route(manifest) {
  return manifest.routes.find((route) => route.route === "/404");
}
export {
  handleRoute,
  matchRoute
};
