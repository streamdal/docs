import fs from 'node:fs';
import path from 'node:path';
import { createSyncFn } from 'synckit';

const last = (items) => (
  // eslint-disable-next-line unicorn/prefer-at -- FIXME: Node 16.6+ required
  items && items[items.length - 1]
);
const arrayify = (...args) => args.reduce((arr, curr) => {
  arr.push(...Array.isArray(curr) ? curr : curr == null ? [] : [curr]);
  return arr;
}, []);
const getPhysicalFilename = (filename, child) => {
  try {
    if (fs.statSync(filename).isDirectory()) {
      return child || filename;
    }
  } catch (err) {
    const { code } = err;
    if (code === "ENOTDIR" || code === "ENOENT") {
      return getPhysicalFilename(path.dirname(filename), filename);
    }
  }
  return filename;
};
const loadEsmModule = (modulePath) => (
  // eslint-disable-next-line @typescript-eslint/no-implied-eval, no-new-func
  new Function("modulePath", `return import(modulePath);`)(
    modulePath
  )
);
const getPositionAtFactory = (text) => {
  const lines = text.split("\n");
  return (offset) => {
    let currOffset = 0;
    for (const [index, line_] of lines.entries()) {
      const line = index + 1;
      const nextOffset = currOffset + line_.length;
      if (nextOffset >= offset) {
        return {
          line,
          column: offset - currOffset,
          offset
        };
      }
      currOffset = nextOffset + 1;
    }
  };
};
const normalizePosition = ({
  start,
  end,
  text
}) => {
  const startOffset = start.offset;
  const endOffset = end.offset;
  const range = [startOffset, endOffset];
  const getPositionAt = text == null ? null : (
    /* istanbul ignore next -- used in worker */
    getPositionAtFactory(text)
  );
  return {
    start: startOffset,
    end: endOffset,
    loc: {
      start: (
        /* istanbul ignore next -- used in worker */
        "line" in start ? start : getPositionAt(startOffset)
      ),
      end: (
        /* istanbul ignore next -- used in worker */
        "line" in end ? end : getPositionAt(endOffset)
      )
    },
    range
  };
};
const prevCharOffsetFactory = (text) => (offset) => {
  for (let i = offset; i >= 0; i--) {
    const char = text[i];
    if (/^\S$/.test(char)) {
      return i;
    }
  }
};
const nextCharOffsetFactory = (text) => {
  const total = text.length;
  return (offset) => {
    for (let i = offset; i <= total; i++) {
      const char = text[i];
      if (/^\S$/.test(char)) {
        return i;
      }
    }
  };
};

var name = "eslint-mdx";
var version = "2.2.0";

const meta = { name, version };

const workerPath = require.resolve("./worker");
const performSyncWork = createSyncFn(workerPath);

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
const DEFAULT_EXTENSIONS = [".mdx"];
const MARKDOWN_EXTENSIONS = [".md"];
class Parser {
  constructor() {
    this.parse = this.parse.bind(this);
    this.parseForESLint = this.parseForESLint.bind(this);
  }
  parse(code, options) {
    return this.parseForESLint(code, options).ast;
  }
  parseForESLint(code, {
    filePath,
    sourceType,
    ignoreRemarkConfig,
    extensions,
    markdownExtensions
  }) {
    var _a;
    const extname = path.extname(filePath);
    const isMdx = [...DEFAULT_EXTENSIONS, ...arrayify(extensions)].includes(
      extname
    );
    const isMarkdown = [
      ...MARKDOWN_EXTENSIONS,
      ...arrayify(markdownExtensions)
    ].includes(extname);
    if (!isMdx && !isMarkdown) {
      throw new Error(
        "Unsupported file extension, make sure setting the `extensions` or `markdownExtensions` option correctly."
      );
    }
    const physicalFilename = getPhysicalFilename(filePath);
    let result;
    try {
      result = performSyncWork({
        fileOptions: {
          path: physicalFilename,
          value: code
        },
        physicalFilename,
        isMdx,
        ignoreRemarkConfig
      });
    } catch (err) {
      const error = err;
      throw Object.assign(new SyntaxError(error.message), {
        lineNumber: error.line,
        column: error.column,
        index: (
          /* istanbul ignore next */
          (_a = error.position) == null ? void 0 : _a.start.offset
        )
      });
    }
    const { root, body, comments, tokens } = result;
    return {
      ast: __spreadProps(__spreadValues({}, normalizePosition(root.position)), {
        type: "Program",
        sourceType,
        body,
        comments,
        tokens
      })
    };
  }
}
const parser = new Parser();
const { parse, parseForESLint } = parser;

export { DEFAULT_EXTENSIONS, MARKDOWN_EXTENSIONS, Parser, arrayify, getPhysicalFilename, getPositionAtFactory, last, loadEsmModule, meta, nextCharOffsetFactory, normalizePosition, parse, parseForESLint, parser, performSyncWork, prevCharOffsetFactory };
